{{$engine := . -}}

{{range $engine.Package.Modules.Modules -}}
{{$module := . -}}
{{$functionSignature := $engine.FunctionSignature $module}}
#[no_mangle]
pub extern "C" fn {{$functionSignature.Name}}({{range $i, $value := $functionSignature.Arguments}}
    {{- if ne $value.ModuleInput.GetStore nil }}
        {{$value.Name}}_ptr: *mut u8,
    {{- else}}
        {{$value.Name}}_ptr: *mut u8,
        {{$value.Name}}_len: usize{{end}},
    {{- end }}
) {
    substreams::register_panic_hook();
    let func = || -> Result<{{$functionSignature.OutputType}}}, Error> {
        {{if ne $module.GetKindStore nil -}}{{/* This is the store for a store module*/}}
        {{writableStoreDeclaration $module.GetKindStore }}
        {{end -}}

        {{ range $id, $argument := $functionSignature.Arguments }}
            {{- if eq $argument.ModuleInput.GetStore nil }}
        let {{$argument.Name}}: {{$argument.Type}} = substreams::proto::decode_ptr({{$argument.Name}}_ptr, {{$argument.Name}}_len).unwrap();
            {{- else}}
            {{- $m := $engine.MustModule $argument.Name }}
        {{readableStoreDeclaration $argument.Name $m.GetKindStore $argument.ModuleInput.GetStore}}
            {{end -}}
        {{end }}

        {{.Name}}(
        {{- range $id, $argument := $functionSignature.Arguments}}
            {{- if isDelta $argument.ModuleInput }}{{/* delta mode */}}
            {{$argument.Name}}_deltas,
            {{- else}}
            {{$argument.Name}},
            {{end -}}
        {{end}}
        {{- if ne $module.GetKindStore nil}}
            store,
        {{end -}}
        )
    };
    let result = func();
    if result.is_err() {
        {
            ::std::rt::panic_fmt(::core::fmt::Arguments::new_v1(
                &[""],
                &[::core::fmt::ArgumentV1::new_debug(&result.err().unwrap())],
            ))
        }
    }
    substreams::output(result.unwrap());
}
{{end -}}